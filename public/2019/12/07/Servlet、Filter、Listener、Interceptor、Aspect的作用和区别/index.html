<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="luckyxue&#39;s blog">
    <meta name="keyword" content="luckyxue blog 憨才好运">
    <link rel="shortcut icon" href="/blog/img/ironman-draw.png">
    <meta property="og:url" content="https://hancaihaoyun.gitee.io/blog/">
 <meta property="og:type" content="article">
 <meta property="og:title" content="hancaihaoyun's blog">
 <meta property="og:description" content="welcome to follow me">
 <meta property="og:image" content="https://hancaihaoyun.gitee.io/blog/img/icon_wechat.png">
    <!-- Place this tag in your head or just before your close body tag.
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Servlet、Filter、Listener、Interceptor、Aspect的作用和区别 - 憨才好运 - Blog
        
    </title>

    <link rel="canonical" href="https://hancaihaoyun.gitee.io/blog/blog/2019/12/07/Servlet、Filter、Listener、Interceptor、Aspect的作用和区别/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/blog/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/blog/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/blog/css/highlight.css">

    <link rel="stylesheet" href="/blog/css/widget.css">

    <link rel="stylesheet" href="/blog/css/rocket.css">

    <link rel="stylesheet" href="/blog/css/signature.css">

    <link rel="stylesheet" href="/blog/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('null')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/blog/img/signature/LuckyxueSign-white.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/blog/tags/#Java Web" title="Java Web">Java Web</a>
                            
                        </div>
                        <h1>Servlet、Filter、Listener、Interceptor、Aspect的作用和区别</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Lucky Xue on
                            2019-12-07
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog/">憨才好运</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/blog/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/blog/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/blog/about/">About Me</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/blog/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="概念">概念</h1>
<h2 id="servlet类">Servlet类</h2>
<p>Servlet是一种运行服务器端的Java应用程序，具有独立于平台和协议的特性，并且可以动态的生成Web页面，它工作在客户端请求与服务器响应的中间层。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态Web内容。这个过程为：</p>
<ul>
<li>客户端发送请求至服务器端；</li>
<li>服务器将请求信息发送至Servlet；</li>
<li>Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；</li>
<li>服务器将响应返回给客户端。</li>
</ul>
<p>在 Web 应用程序中，一个 Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。如果 Servlet 不涉及共享资源的问题，不必关心多线程问题。但如果 Servlet 需要共享资源，需要保证 Servlet 是线程安全的。最新版本3.1，为了简化开发流程，Servlet 3.0 引入了注解（annotation），这使得 web 部署描述符 web.xml 不再是必须的选择。</p>
<p>SpringBoot使用注解实现一个简单的Servlet，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/myServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyServlet's doGet() method is invoked."</span>);</span><br><span class="line">        doAction(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyServlet's doPost() method is invoked."</span>);</span><br><span class="line">        doAction(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String name = req.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        resp.setContentType(<span class="string">"text/plain"</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">"Hello "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地访问URL：localhost:8080/myServlet?name=hancaihaoyun，执行结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">========time filter init========</span><br><span class="line">========time filter start========</span><br><span class="line"><span class="function">MyFilter <span class="title">doFilter</span><span class="params">()</span> is invoked.</span></span><br><span class="line"><span class="function">Parameter:name  Value:hancaihaoyun</span></span><br><span class="line"><span class="function">MyServlet's <span class="title">doGet</span><span class="params">()</span> method is invoked.</span></span><br><span class="line"><span class="function">time filter cost 5 ms</span></span><br><span class="line"><span class="function"></span>=======time filter end========</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:64420'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">========time filter destroy========</span><br></pre></td></tr></table></figure>
<h3 id="servlet同词多义">Servlet同词多义</h3>
<p>在工作中我们反复遇到Servlet这个名词，在不同的语境下其实表示的是不同的含义。早期为了实现HTTP服务器和业务类解耦，定义了Servlet接口，各个业务类都必须实现这个这个接口，有时我们也把实现了Servlet接口的业务类叫做Servlet。后续又发明了Servlet容器，Servlet容器用来加载和管理业务类，HTTP服务器不直接跟业务类打交道，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet，如果这个Servlet还没有创建，就加载并实例化这个Servlet，然后调用这个Servlet的接口方法，因此Servlet接口其实是Servlet容器跟具体业务类之间的接口，而Servlet接口和Servlet容器这一整套的规范叫做Servlet规范。</p>
<img src="abbe277236d28d6db7f4d8b71079899d.jpg" alt="continuous_deployment" data-action="zoom">
<h3 id="servlet容器与spring容器有什么关系">Servlet容器与Spring容器有什么关系?</h3>
<p>Tomcat&amp;Jetty在启动时给每个Web应用创建一个全局的上下文环境，这个上下文就是ServletContext，其为后面的Spring容器提供宿主环境。</p>
<p>Tomcat&amp;Jetty在启动过程中触发容器初始化事件，Spring的ContextLoaderListener会监听到这个事件，它的contextInitialized方法会被调用，在这个方法中，Spring会初始化全局的Spring根容器，这个就是Spring的IoC容器，IoC容器初始化完毕后，Spring将其存储到ServletContext中，便于以后来获取。</p>
<p>Tomcat&amp;Jetty在启动过程中还会扫描Servlet，一个Web应用中的Servlet可以有多个，以SpringMVC中的DispatcherServlet为例，这个Servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个Servlet请求。</p>
<p>Servlet一般会延迟加载，当第一个请求达到时，Tomcat&amp;Jetty发现DispatcherServlet还没有被实例化，就调用DispatcherServlet的init方法，DispatcherServlet在初始化的时候会建立自己的容器，叫做SpringMVC 容器，用来持有Spring MVC相关的Bean。同时，Spring MVC还会通过ServletContext拿到Spring根容器，并将Spring根容器设为SpringMVC容器的父容器，请注意，Spring MVC容器可以访问父容器中的Bean，但是父容器不能访问子容器的Bean，也就是说Spring根容器不能访问SpringMVC容器里的Bean。说的通俗点就是，在Controller里可以访问Service对象，但是在Service里不可以访问Controller对象。</p>
<p>Spring容器是管理Service和Dao的，SpringMVC容器是管理Controller对象的，Servlet容器是管理Servlet对象的，单独使用Servlet时，Servlet容器是根据url等信息，选择将请求交给哪个Servlet来处理。使用SpringMVC时，Servlet容器将请求交给SpringMVC的DispatchServlet来处理。</p>
<h2 id="filter过滤器">Filter过滤器</h2>
<p>Filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml 文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。Filter可认为是Servlet的一种“变种”，它主要用于对用户请求HttpServletRequest进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<p>Filter有如下几个用处:</p>
<ul>
<li>
<p>HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。</p>
</li>
<li>
<p>根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。</p>
</li>
<li>
<p>在HttpServletResponse到达客户端之前，拦截HttpServletResponse。</p>
</li>
<li>
<p>根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</p>
</li>
</ul>
<p>Filter有如下几个种类:</p>
<ul>
<li>
<p>用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。</p>
</li>
<li>
<p>日志Filter：详细记录某些特殊的用户请求。</p>
</li>
<li>
<p>负责解码的Filter：包括对非标准编码的请求解码。</p>
</li>
<li>
<p>能改变XML内容的XSLT Filter等。</p>
</li>
</ul>
<p>Filter可负责拦截多个请求或响应；一个请求或响应也可被多个请求拦截。</p>
<p>创建一个Filter只需两个步骤：</p>
<ul>
<li>
<p>创建Filter处理类；</p>
</li>
<li>
<p>web.xml文件中配置Filter。</p>
</li>
</ul>
<p>SpringBoot使用注解实现一个简单的Filter，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========time filter start========"</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"MyFilter doFilter() is invoked."</span>);</span><br><span class="line">        Enumeration&lt;String&gt; params = req.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (params.hasMoreElements()) &#123;</span><br><span class="line">            String param=params.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"Parameter:"</span>+param+<span class="string">"\tValue:"</span>+req.getParameter(param));</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time filter cost "</span> + (endTime - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"=======time filter end========"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========time filter init========"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========time filter destroy========"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序实现了doFilter()方法，实现该方法就可实现对用户请求进行预处理，也可实现对服务器响应进行后处理——它们的分界线为是否调用了chain.doFilter()，执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。</p>
<p>为了更好地测试，我们增加一个UserController类，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========MyController getUserInfo method start========"</span>);</span><br><span class="line">        <span class="comment">// mock user info dao</span></span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.setUserId(id);</span><br><span class="line">        userInfo.setUserName(<span class="string">"憨才好运"</span>);</span><br><span class="line">        userInfo.setAge(<span class="number">26</span>);</span><br><span class="line">        System.out.println(<span class="string">"========MyController getUserInfo method end========"</span>);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地访问URL：localhost:8080/user/1，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">========time filter init========</span><br><span class="line">========time filter start========</span><br><span class="line"><span class="function">MyFilter <span class="title">doFilter</span><span class="params">()</span> is invoked.</span></span><br><span class="line"><span class="function"></span>========MyController getUserInfo method start========</span><br><span class="line">========MyController getUserInfo method end========</span><br><span class="line">time filter cost <span class="number">71</span> ms</span><br><span class="line">=======time filter end========</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:50688'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">========time filter destroy========</span><br></pre></td></tr></table></figure>
<p>我们再来看看doFilter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br></pre></td></tr></table></figure>
<p>从参数我们看到，filter里面是能够获取到请求的参数和响应的数据；但此方法是无法知道是哪一个Controller类中的哪个方法被执行。还有一点需要注意的是，filter中是没法使用注入的bean的，也就是无法使用@Autowire。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里获取的userInfo实例为null</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码注入的值为Null，这是为什么呢？</p>
<p>其实Spring中，web应用启动的顺序是：Listener-&gt;Filter-&gt;Servlet，先初始化Listener，然后再来就Filter的初始化，再接着才到我们的DispathServlet的初始化，因此，当我们需要在Filter里注入一个注解的Bean时，就会注入失败，因为Filter初始化时，注解的bean还没初始化，没法注入。</p>
<p>在上面的请求Filter中，仅记录请求的URL的耗时，对所有的请求都执行chain.doFilter (request,reponse)方法，当Filter对请求过滤后，依然将请求发送到目的地址。如果需要检查权限，可以在Filter中根据用户请求 的HttpSession，判断用户权限是否足够。如果权限不够，直接调用重定向即可，无须调用 chain.doFilter(request,reponse)方法。</p>
<p>在web.xml文件中我们需要对其需要拦截的请求配置监听范围，或者说过滤哪些url。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.springboot.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置过滤的范围 后缀符合即过滤 此处为全部过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在web.xml文件中配置该Filter，使用init-param元素为该Filter配置参数，init-param可接受如下两个子元素：<br>
param-name：指定参数名；<br>
param-value：指定参数值；<br>
其实struts2本身就依托于一个总过滤器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个匹配的Filter，是按照其在web.xml中配置的顺序来执行的。</p>
<p>所以这也就是，把自己的Filter或者其他的Filter（比如UrlRewrite的Filter）放在Struts的DispatcherFilter的前面的原因。因为，它们需要在请求被Struts2框架处理之前，做一些前置的工作。</p>
<p>当Filter被调用，并且进入了Struts2的DispatcherFilter中后，Struts2会按照在Action中配置的Interceptor Stack中的Interceptor的顺序，来调用Interceptor。</p>
<p>这里需要注意的是，在SpringBoot中直接使用注解@Order指定顺序会失效，默认是使用Filter的类名的单词顺序排序的，需要在Configuration中注册过滤器才行。</p>
<p><a href="https://blog.csdn.net/ieen_csdn/article/details/86612492" target="_blank" rel="noopener">Spring Boot 之 Filter顺序配置 @Order无效原因解读</a></p>
<p><a href="https://www.jianshu.com/p/7e1cfe750d55" target="_blank" rel="noopener">spring Filter 中使用@Autowired 方法</a></p>
<p><a href="https://www.cnblogs.com/EasonJim/p/7666009.html" target="_blank" rel="noopener">Spring在Java Filter注入Bean为Null的问题解决</a></p>
<h2 id="listener监听器">Listener监听器</h2>
<p>监听器，从字面上可以看出Listener主要用来监听应用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的语言说就是在application，session，request三个对象创建消亡或者往其中添加修改删除属性时自动执行代码的功能组件。比如spring 的总监听器会在服务器启动的时候实例化我们配置的bean对象 、hibernate 的 session 的监听器会监听session的活动和生命周期，负责创建、关闭session等活动。</p>
<p>Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。</p>
<p>SpringBoot使用注解实现一个简单的Listener，来监听Tomcat容器中的ServletContext初始化和销毁的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyServletContextListener Context Initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyServletContextListener Context Destroyed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地访问URL：localhost:8080/user/1，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyServletContextListener Context Initialized</span><br><span class="line">========MyController getUserInfo method start========</span><br><span class="line">========MyController getUserInfo method end========</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:50726'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">21</span>:<span class="number">54</span>:<span class="number">11.105</span>  INFO <span class="number">16704</span> --- [       Thread-<span class="number">5</span>] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService <span class="string">'applicationTaskExecutor'</span></span><br><span class="line">MyServletContextListener Context Destroyed</span><br></pre></td></tr></table></figure>
<h2 id="interceptor拦截器">Interceptor拦截器</h2>
<p>Interceptor依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法，是基于JAVA的反射机制。比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。</p>
<p>Servlet、Filter、Listener是配置到web.xml中（web.xml 的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servlet ），Interceptor不配置到web.xml中，Struts的拦截器配置到struts.xml中，Spring的拦截器配置到spring.xml中。</p>
<p>SpringBoot使用注解实现一个简单的拦截器，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========preHandle======="</span>);</span><br><span class="line">        System.out.println(((HandlerMethod) handler).getBean().getClass().getName());</span><br><span class="line">        System.out.println(((HandlerMethod) handler).getMethod().getName());</span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>, <span class="keyword">new</span> Date().getTime());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========postHandle======="</span>);</span><br><span class="line">        Long startTime = (Long) request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        System.out.println(<span class="string">"time interceptor postHandle cost "</span> + (<span class="keyword">new</span> Date().getTime() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========afterCompletion========"</span>);</span><br><span class="line">        Long startTime = (Long) request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        System.out.println(<span class="string">"time interceptor afterCompletion cost "</span> + (<span class="keyword">new</span> Date().getTime() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ex is "</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WebMvcConfigurationSupport配置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor myInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        addPathPatterns("/api/**")配置拦截路径，其中/**表示当前目录以及所有子目录（递归），/*表示当前目录，不包括子目录</span></span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地访问URL：localhost:8080/user/1，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=========preHandle=======</span><br><span class="line">com.springboot.controller.MyController</span><br><span class="line">getUserInfo</span><br><span class="line">========MyController getUserInfo method start========</span><br><span class="line">========MyController getUserInfo method end========</span><br><span class="line">========postHandle=======</span><br><span class="line">time interceptor postHandle cost <span class="number">70</span> ms</span><br><span class="line">========afterCompletion========</span><br><span class="line">time interceptor afterCompletion cost <span class="number">71</span> ms</span><br><span class="line">ex is <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>我们发现拦截器中可以获取到Controller对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br></pre></td></tr></table></figure>
<p>object handler就是controller方法对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HandlerMethod handlerMethod = (HandlerMethod)handler;</span><br><span class="line">handlerMethod.getBean().getClass().getName(); <span class="comment">//获取类名</span></span><br><span class="line">handlerMethod.getMethod().getName(); <span class="comment">//获取方法名</span></span><br></pre></td></tr></table></figure>
<p>但我们发现获取不到方法的参数值，这个是为什么呢？在DispatcherServlet类中，方法doDispatch(HttpServletRequest request, HttpServletResponse response)</p>
<img src="d8de0d72a44c5b566176321e7a851882.jpg" alt="continuous_deployment" data-action="zoom">
<p>applyPreHandle这个方法执行，就是执行的拦截器的preHandler方法，但这个过程中，controller方法没有从request中获取请求参数，组装方法参数；而是在ha.handle这个方法的时候，才会组装参数</p>
<p>虽然没法得到方法的参数，但是可以获得IOC的Bean哦。</p>
<p>再说明一点的是postHandler方法</p>
<p>postHandler方法的执行，当controller内部有异常，posthandler方法是不会执行的。</p>
<p>afterCompletion方法，不管controller内部是否有异常，都会执行此方法；此方法还会有个Exception ex这个参数；如果有异常，ex会有异常值；没有异常 此值为null</p>
<p>注意点如果controller内部有异常，但异常被@ControllerAdvice 异常统一捕获的话，ex也会为null</p>
<p><a href="https://www.cnblogs.com/longxok/articles/10844138.html" target="_blank" rel="noopener">Spring Boot 拦截器无效，不起作用</a></p>
<h2 id="aspect切面">Aspect切面</h2>
<p>AOP(Aspect Oriented Programming)，是面向切面编程的技术。AOP基于IoC基础，是对OOP的有益补充。<br>
AOP之所以能得到广泛认可，主要是因为它将应用系统拆分分了2个部分：核心业务逻辑（Core business concerns）及横向的通用逻辑，也就是所谓的切面Crosscutting enterprise concerns。例如，所有大中型应用都要涉及到的持久化管理（Persistent）、事务管理（Transaction Management）、权限管理（Privilege Management）、日志管理（Logging）和调试管理（Debugging）等。使用AOP技术，可以让开发人员只专注核心业务，而通用逻辑则使用AOP技术进行横向切入，由专人去处理这些通用逻辑，会使得任务简单明了，提高开发和调试的效率。<br>
AOP操作可以对操作进行横向的拦截,最大的优势在于可以获取执行方法的参数，对方法进行统一的处理。常见使用日志、事务、请求参数安全验证。</p>
<p>SpringBoot使用注解实现一个简单的时间统计切面，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.springboot.controller.MyController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handlerControllerMethod</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========time aspect begin======"</span>);</span><br><span class="line">        Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arg is "</span> + arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">        Object object = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"time aspect cost "</span> + (<span class="keyword">new</span> Date().getTime() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"=======time aspect end======="</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们是可以获取方法的参数的，本地访问URL：localhost:8080/user/1，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">========time aspect begin======</span><br><span class="line">arg is <span class="number">1</span></span><br><span class="line">========MyController getUserInfo method start========</span><br><span class="line">========MyController getUserInfo method end========</span><br><span class="line">time aspect cost <span class="number">3</span> ms</span><br><span class="line">=======time aspect end=======</span><br></pre></td></tr></table></figure>
<p>虽然切面aop可以拿到方法参数，但拿不到response，request对象。</p>
<h1 id="生命周期">生命周期</h1>
<h2 id="servlet类">Servlet类</h2>
<p>一般继承HttpServlet（一般的，通用Servlet由javax.servlet.GenericServlet实现Servlet接口。程序设计人员可以通过使用或继承这个类来实现通用Servlet应用。javax.servlet.http.HttpServlet实现了专门用于响应HTTP请求的Servlet，提供了响应对应HTTP标准请求的doGet()、doPost()等方法），web.xml配置servlet时如果加上load-on-start=1，Web应用启动时候加载Servlet。（在servlet的配置当中，<load-onstartup>1的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个Servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。）</load-onstartup></p>
<p>当Servlet被部署在应用服务器中（应用服务器中用于管理Java组件的部分被抽象成为容器） 以后，由容器控制Servlet的生命周期。除非特殊指定，否则在容器启动的时候，Servlet是不会被加载的，Servlet只会在第一次请求的时候被加载和实例化。Servlet一旦被加载，一般不会从容器中删除，直至应用服务器关闭或重新启动。但当容器做内存回收动作时，Servlet有可能被删除。也正是因为这个原因，第一次访问Servlet所用的时间要大大多于以后访问所用的时间。</p>
<p>Servlet在服务器的运行生命周期为，在第一次请求（或其实体被内存垃圾回收后再被访问）时被加载并执行一次初始化方法，跟着执行正式运行方法，之后会被常驻并每次被请求时直接执行正式运行方法，直到服务器关闭或被清理时执行一次销毁方法后实体销毁。Java服务器页面（JSP）是HttpServlet的扩展。由于HttpServlet大多是用来响应HTTP请求，并返回Web页面（例如HTML、XML）， 所以不可避免地，在编写Servlet时会涉及大量的HTML内容，这给Servlet的书写效率和可读性带来很大障碍，JSP便是在这个基础上产生的。其功能是使用HTML的书写格式，在适当的地方加入Java代码片断，将程序员从复杂的HTML中解放出来，更专注于Servlet本身的内容。JSP在首次被访问的时候被应用服务器转换为Servlet，在以后的运行中，容器直接调用这个Servlet，而不再访问JSP页面。JSP的实质仍然是Servlet。</p>
<ul>
<li>(1)装入：启动服务器时加载Servlet的实例；</li>
<li>(2)初始化：Web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作由init()方法负责执行完成；</li>
<li>(3)调用：从第一次到以后的多次访问，都是只调用doGet()或doPost()方法；</li>
<li>(4)销毁：停止服务器时调用destroy()方法，销毁实例。</li>
</ul>
<h2 id="filter过滤器">Filter过滤器</h2>
<p>Filter必须实现javax.Servlet.Filter接口，并且必须定义以下三个方法:init()，destory()，doFilter()，空实现也行。</p>
<ul>
<li>(1)启动服务器时加载过滤器的实例，并调用init()方法来初始化实例；</li>
<li>(2)每一次请求时都只调用方法doFilter()进行处理；</li>
<li>(3)停止服务器时调用destroy()方法，销毁实例。</li>
</ul>
<h2 id="listener监听器">Listener监听器</h2>
<p>Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。</p>
<p>web.xml 的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servlet</p>
<h2 id="interceptor拦截器">Interceptor拦截器</h2>
<p>以Struts的拦截器为例，加载了struts.xml以后，初始化相应拦截器。当action请求来时调用intercept方法，服务器停止销毁interceptor。</p>
<h1 id="职责">职责</h1>
<h2 id="servlet类">Servlet类</h2>
<ul>
<li>
<p>创建并返回一个包含基于客户请求性质的动态内容的完整的html页面；</p>
</li>
<li>
<p>创建可嵌入到现有的html页面中的一部分html页面（html片段）；</p>
</li>
<li>
<p>读取客户端发来的隐藏数据；</p>
</li>
<li>
<p>读取客户端发来的显示数据；</p>
</li>
<li>
<p>与其他服务器资源（包括数据库和java的应用程序）进行通信；</p>
</li>
<li>
<p>通过状态代码和响应头向客户端发送隐藏数据。</p>
</li>
</ul>
<h2 id="filter过滤器">Filter过滤器</h2>
<p>Filter能够在一个请求到达servlet之前预处理用户请求，也可以在离开Servlet时处理http响应：</p>
<ul>
<li>
<p>在执行Servlet之前，首先执行Filter程序，并为之做一些预处理工作；</p>
</li>
<li>
<p>根据程序需要修改请求和响应；</p>
</li>
<li>
<p>在Servlet被调用之后截获Servlet的执行</p>
</li>
</ul>
<h2 id="listener监听器">Listener监听器</h2>
<p>Servlet2.4规范中提供了8个Listener接口，可以将其分为三类，分别如下：</p>
<ul>
<li>
<p>第一类：与ServletContext有关的Listener接口。包括：ServletContextListener、ServletContextAttributeListener</p>
</li>
<li>
<p>第二类：与HttpSession有关的Listner接口。包括：HttpSessionListener、 HttpSessionAttributeListener、HttpSessionBindingListener、                     HttpSessionActivationListener；</p>
</li>
<li>
<p>第三类：与ServletRequest有关的Listener接口，包括：ServletRequestListner、ServletRequestAttributeListener</p>
</li>
</ul>
<h2 id="interceptor拦截器">Interceptor拦截器</h2>
<p>与过滤器十分相似，通过层层拦截，处理用户的请求和响应。</p>
<h1 id="区别">区别</h1>
<p>1、Servlet 流程是短的，url传来之后，就对其进行处理，之后返回或转向到某一自己指定的页面。它主要用来在业务处理之前进行控制。<br>
2、Filter 流程是线性的， url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个Filter, Servlet接收等，而Servlet 处理之后，不会继续向下传递。Filter功能可用来保持流程继续按照原来的方式进行下去，或者主导流程，而servlet的功能主要用来主导流程。<br>
Filter可用来进行字符编码的过滤，检测用户是否登陆的过滤，禁止页面缓存等。<br>
3、Servlet，Filter都是针对url之类的，而Listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。<br>
可用来进行：Spring整合Struts,为Struts的action注入属性，Web应用定时任务的实现，在线人数的统计等<br>
4、Interceptor 拦截器，类似于Filter,不过在struts.xml中配置，不是在web.xml,并且不是针对URL的，而是针对action,当页面提交 action时，进行过滤操作，相当于struts1.x提供的plug-in机制，可以看作，前者是Struts1.x自带的Filter,而 Interceptor 是struts2 提供的Filter.<br>
与filter不同点：</p>
<ul>
<li>(1)不在web.xml中配置，而是在struts.xml中完成配置，与action在一起</li>
<li>(2)可由action自己指定用哪个interceptor 来在接收之前做事</li>
</ul>
<p>5、Struts2中的过滤器和拦截器的区别与联系：<br>
-（1）拦截器是基于java反射机制的，而过滤器是基于函数回调的。<br>
-（2）过滤器依赖与servlet容器，而拦截器不依赖与servlet容器。<br>
-（3）拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。<br>
-（4）拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。<br>
-（5）在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。<br>
大家应该听说过过滤器、拦截器、切面，印象上都能够起到截断拦截的作用，在做一些业务需求时，不知道如何选择。下面就来介绍一下他们之间的区别。我们这里来总结一下过滤器、拦截器、Aspect，看看区别：</p>
<img src="793cec612e7cd213a8d9921bd619502b.jpg" alt="continuous_deployment" data-action="zoom">
<p>如果三者方式同时采用，那他们的执行顺序是什么呢？</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F<span class="function"><span class="title">ilter</span> -&gt;</span> I<span class="function"><span class="title">nterceptor</span> -&gt;</span> C<span class="function"><span class="title">ontrollerAdvice</span> -&gt;</span> A<span class="function"><span class="title">spect</span> -&gt;</span> Controller</span><br></pre></td></tr></table></figure>
<p>返回值顺序，或异常返回顺序</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C<span class="function"><span class="title">ontroller</span> -&gt;</span> A<span class="function"><span class="title">spect</span> -&gt;</span> C<span class="function"><span class="title">ontrollerAdvice</span> -&gt;</span> I<span class="function"><span class="title">nterceptor</span> -&gt;</span> Filter</span><br></pre></td></tr></table></figure>
<p>将上述的各个模块的代码整合在一起，同样访问本地URL：localhost:8080/user/1，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">========time filter init========</span><br><span class="line">========time filter start========</span><br><span class="line"><span class="function">MyFilter <span class="title">doFilter</span><span class="params">()</span> is invoked.</span></span><br><span class="line"><span class="function"></span>=========preHandle=======</span><br><span class="line">com.springboot.controller.MyController$$EnhancerBySpringCGLIB$$e365864</span><br><span class="line">getUserInfo</span><br><span class="line">========time aspect begin======</span><br><span class="line">arg is <span class="number">1</span></span><br><span class="line">========MyController getUserInfo method start========</span><br><span class="line">========MyController getUserInfo method end========</span><br><span class="line">time aspect cost <span class="number">3</span> ms</span><br><span class="line">=======time aspect end=======</span><br><span class="line">========postHandle=======</span><br><span class="line">time interceptor postHandle cost <span class="number">160</span> ms</span><br><span class="line">========afterCompletion========</span><br><span class="line">time interceptor afterCompletion cost <span class="number">160</span> ms</span><br><span class="line">ex is <span class="keyword">null</span></span><br><span class="line">time filter cost <span class="number">171</span> ms</span><br><span class="line">=======time filter end========</span><br></pre></td></tr></table></figure>
<p>用一个图描述一下执行顺序如下：</p>
<img src="1f7096242bc7b3d6e1c45f884a1f3249.jpg" alt="continuous_deployment" data-action="zoom">
<h1 id="执行流程图">执行流程图</h1>
<h2 id="servlet类">Servlet类</h2>
<img src="a52e960f6ab7739951017353241ff708.jpg" alt="continuous_deployment" data-action="zoom">
<h2 id="filter过滤器">Filter过滤器</h2>
<img src="c9461e6b3541d56c4dc0f2a226b6744b.jpg" alt="continuous_deployment" data-action="zoom">
<h2 id="listener监听器">Listener监听器</h2>
<img src="eea96ba443c51ce95dd181983a858056.jpg" alt="continuous_deployment" data-action="zoom">
<h2 id="interceptor拦截器">Interceptor拦截器</h2>
<img src="af05d376c54a17effec3d880a8d848b8.jpg" alt="continuous_deployment" data-action="zoom">
<h2 id="aop切面">Aop切面</h2>
<img src="2ff6d6e5b240c581873e4b6236c1bec9.jpg" alt="continuous_deployment" data-action="zoom">
<h1 id="本文测试代码">本文测试代码</h1>
<p><a href="https://gitee.com/hancaihaoyun/spring-buckets-demo/tree/master/ServletFilterListenerInterceptorAop" target="_blank" rel="noopener">ServletFilterListenerInterceptorAop</a></p>
<p>关注【憨才好运】微信公众号，了解更多精彩内容⬇️⬇️⬇️</p>
<img src="1584253178882.jpg" alt="continuous_deployment" data-action="zoom">

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/blog/2019/12/16/深入理解Cookie和Session/" data-toggle="tooltip" data-placement="top" title="深入理解Cookie和Session">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/blog/2019/07/07/MySQL在MyBatis环境下批量进行存在则更新，不存在则插入/" data-toggle="tooltip" data-placement="top" title="MySQL在MyBatis环境下批量进行存在则更新，不存在则插入">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- Gitalk start -->
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
                <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
                <div id="gitalk-container"></div>
                <script src="/js/md5.min.js"></script>
                <script type="text/javascript">
                    var gitalk = new Gitalk({
                            clientID: '7fc6e38b7a2eba7640a3',
                            clientSecret: '1004c04785519326bdc8fea59b9b93842168686d',
                            repo: 'luckyxue.github.io',  //如 'convivae.github.io'
                            owner: 'luckyxue',
                            admin: ['luckyxue'], //这是个字符串数组，可填写多个
                            id: md5(location.pathname),      // 页面的唯一标识。长度必须小于50，默认是文章路径
                            distractionFreeMode: true  // 类似Facebook评论框的全屏遮罩效果.
                        });
                    gitalk.render('gitalk-container');
                </script>
                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#概念"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet类"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">Servlet类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#servlet同词多义"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">Servlet同词多义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#servlet容器与spring容器有什么关系"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">Servlet容器与Spring容器有什么关系?</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#filter过滤器"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">Filter过滤器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#listener监听器"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">Listener监听器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#interceptor拦截器"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">Interceptor拦截器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#aspect切面"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">Aspect切面</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#生命周期"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">生命周期</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet类"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Servlet类</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#filter过滤器"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Filter过滤器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#listener监听器"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">Listener监听器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#interceptor拦截器"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">Interceptor拦截器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#职责"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">职责</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet类"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">Servlet类</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#filter过滤器"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">Filter过滤器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#listener监听器"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">Listener监听器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#interceptor拦截器"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">Interceptor拦截器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#区别"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">区别</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#执行流程图"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">执行流程图</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#servlet类"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">Servlet类</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#filter过滤器"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">Filter过滤器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#listener监听器"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">Listener监听器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#interceptor拦截器"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text">Interceptor拦截器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#aop切面"><span class="toc-nav-number">5.5.</span> <span class="toc-nav-text">Aop切面</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#本文测试代码"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">本文测试代码</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/blog/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/blog/tags/#Java Web" title="Java Web">Java Web</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://www.cnblogs.com/luckyxue" target="_blank">luckyxue&#39;s cnblogs</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<script type="text/javascript" src="/js/zooming.js"></script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                
                    <li>
                        <a target="_blank" href="https://www.cnblogs.com/luckyxue">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">博</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://gitee.com/hancaihaoyun">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">码</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/luckyxue">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Lucky Xue 2021 
                    <br>
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Re-Ported by <a href="https://luckyxue.github.io/">LuckyXue</a> 
                    <!-- | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                    -->
                </p>
                <div class="copyright text-muted">
                    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
                    <span class="post-meta-divider">|</span>
                    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>

        </div>

    </div>

   
</footer>

<!-- jQuery -->
<script src="/blog/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/blog/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/blog/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://hancaihaoyun.gitee.io/blog/blog/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- Google Analytics -->




<!-- Baidu Tongji -->



	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://hancaihaoyun.gitee.io/blog/blog/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
